:class SecureRandom
  :is Random

  :const _chunk USize: 256
  :const _limit USize: 2048
  :let _buffer: Bytes.new(@_limit)
  :var _offset USize: 0

  :new: @_grab_random_bytes

  :fun ref u64 U64
    if (@_offset >= @_limit - 64) @_grab_random_bytes

    @_read_64_from_buffer

  // This method will deal with different platforms by selecting the
  // appropriate secure random primitive.
  :fun ref _grab_random_bytes
    @_buffer.resize_possibly_including_uninitialized_memory(@_chunk)

    (@_limit / @_chunk).times -> (i |
      _FFI.getentropy(@_buffer.cpointer(i * @_chunk), @_chunk)
    )

    @_offset = 0

  :fun ref _read_64_from_buffer
    res = try (@_buffer.read_native_u64!(@_offset) | 0)
    @_offset += 64
    res
