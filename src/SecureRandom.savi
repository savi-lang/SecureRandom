:class SecureRandom
  :is Random

  :const _chunk USize: 256
  :const _limit USize: 2048
  :let _buffer: Bytes.new(@_limit)
  :var _offset USize: 0

  :new: @_grab_random_bytes

  :fun ref u64 U64
    if (@_offset >= @_limit - 64) @_grab_random_bytes

    res = try (@_buffer.read_native_u64!(@_offset) | 0), @_offset += 64

    res

  :fun ref u32 U32
    if (@_offset >= @_limit - 32) @_grab_random_bytes

    res = try (@_buffer.read_native_u32!(@_offset) | 0), @_offset += 32

    res

  :fun ref u16 U16
    if (@_offset >= @_limit - 16) @_grab_random_bytes

    res = try (@_buffer.read_native_u16!(@_offset) | 0), @_offset += 16

    res

  :fun ref u8 U8
    if (@_offset >= @_limit - 1) @_grab_random_bytes

    res = try (@_buffer.read_byte!(@_offset) | 0), @_offset += 1

    res

  // This method will deal with different platforms by selecting the
  // appropriate secure random primitive.
  :fun ref _grab_random_bytes
    @_buffer.resize_possibly_including_uninitialized_memory(@_chunk)

    (@_limit / @_chunk).times -> (i |
      _FFI.getentropy(@_buffer.cpointer(i * @_chunk), @_chunk)
    )

    @_offset = 0
